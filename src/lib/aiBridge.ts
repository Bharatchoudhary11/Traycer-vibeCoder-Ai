import {
  CodeChange,
  ImplementationSeedOptions,
  PlanGenerationOptions,
  PlanStep,
  ReviewComment,
  ReviewRunOptions
} from './types';
import {
  generateImplementationSketch as simulateImplementation,
  generatePlanFromPrompt as simulatePlan,
  generateReviewComments as simulateReview
} from './fakeAi';
import { nanoid } from './id';

export type AiProvider = 'live-openai' | 'simulated';

export interface AiPlanResult {
  plan: PlanStep[];
  provider: AiProvider;
  note?: string;
  warning?: string;
}

export interface AiImplementationResult {
  changes: CodeChange[];
  provider: AiProvider;
  note?: string;
  warning?: string;
}

export interface AiReviewResult {
  reviews: ReviewComment[];
  provider: AiProvider;
  note?: string;
  warning?: string;
}

const OPENAI_API_KEY = import.meta.env.VITE_OPENAI_API_KEY;
const OPENAI_MODEL = import.meta.env.VITE_OPENAI_MODEL ?? 'gpt-4o-mini';
const OPENAI_BASE_URL = (import.meta.env.VITE_OPENAI_BASE_URL ?? 'https://api.openai.com/v1').replace(/\/$/, '');

const OPENAI_ENABLED = Boolean(OPENAI_API_KEY);

interface ChatMessage {
  role: 'system' | 'user';
  content: string;
}

function normaliseStatus(value: string | undefined): 'todo' | 'in-progress' | 'done' {
  switch (value) {
    case 'in-progress':
    case 'done':
      return value;
    default:
      return 'todo';
  }
}

function ensurePlanSteps(candidate: unknown): PlanStep[] {
  if (!Array.isArray(candidate)) {
    return [];
  }

  const steps: PlanStep[] = [];
  candidate.forEach((step) => {
    if (!step || typeof step !== 'object') {
      return;
    }

    const record = step as Record<string, unknown>;
    const title = typeof record.title === 'string' ? record.title.trim() : 'Untitled step';
    const detail = typeof record.detail === 'string' ? record.detail.trim() : '';
    const status = normaliseStatus(typeof record.status === 'string' ? record.status : undefined);
    const blockedBy = typeof record.blockedBy === 'string' && record.blockedBy.length ? record.blockedBy : undefined;

    const planStep: PlanStep = {
      id: typeof record.id === 'string' && record.id.length ? record.id : nanoid(),
      title,
      detail,
      status
    };

    if (blockedBy) {
      planStep.blockedBy = blockedBy;
    }

    steps.push(planStep);
  });

  return steps;
}

function ensureCodeChanges(candidate: unknown): CodeChange[] {
  if (!Array.isArray(candidate)) {
    return [];
  }

  const changes: CodeChange[] = [];
  candidate.forEach((change) => {
    if (!change || typeof change !== 'object') {
      return;
    }

    const record = change as Record<string, unknown>;
    const filePath = typeof record.filePath === 'string' ? record.filePath : 'src/index.ts';
    const summary = typeof record.summary === 'string' ? record.summary : 'AI suggested change';
    const rationale = typeof record.rationale === 'string' ? record.rationale : 'Generated by AI provider';
    const before = typeof record.before === 'string' ? record.before : '// previous behaviour';
    const after = typeof record.after === 'string' ? record.after : '// proposed update';
    const status = typeof record.status === 'string' ? record.status : 'draft';
    const relatedPlanStepIds = Array.isArray(record.relatedPlanStepIds)
      ? (record.relatedPlanStepIds.filter((value) => typeof value === 'string') as string[])
      : [];

    const codeChange: CodeChange = {
      id: typeof record.id === 'string' && record.id.length ? record.id : nanoid(),
      filePath,
      summary,
      rationale,
      before,
      after,
      status: (['draft', 'ready', 'in-review'] as const).includes(status as any) ? (status as CodeChange['status']) : 'draft',
      relatedPlanStepIds
    };

    changes.push(codeChange);
  });

  return changes;
}

function ensureReviewComments(candidate: unknown): ReviewComment[] {
  if (!Array.isArray(candidate)) {
    return [];
  }

  const comments: ReviewComment[] = [];
  candidate.forEach((item) => {
    if (!item || typeof item !== 'object') {
      return;
    }

    const record = item as Record<string, unknown>;
    const severity = ['info', 'warning', 'error'].includes(record.severity as string)
      ? (record.severity as ReviewComment['severity'])
      : 'info';

    const review: ReviewComment = {
      id: typeof record.id === 'string' && record.id.length ? record.id : nanoid(),
      filePath: typeof record.filePath === 'string' ? record.filePath : 'src/index.ts',
      message: typeof record.message === 'string' ? record.message : 'AI review feedback',
      severity,
      resolved: Boolean(record.resolved)
    };

    if (typeof record.suggestion === 'string') {
      review.suggestion = record.suggestion;
    }

    if (typeof record.line === 'number') {
      review.line = record.line;
    }

    comments.push(review);
  });

  return comments;
}

async function callOpenAi(messages: ChatMessage[]): Promise<any> {
  if (!OPENAI_ENABLED) {
    throw new Error('OpenAI is not configured.');
  }

  const response = await fetch(`${OPENAI_BASE_URL}/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: OPENAI_MODEL,
      messages,
      temperature: 0.35,
      response_format: { type: 'json_object' }
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OpenAI request failed (${response.status}): ${errorText}`);
  }

  const payload = await response.json();
  const content = payload?.choices?.[0]?.message?.content;

  if (typeof content !== 'string' || !content.trim()) {
    throw new Error('OpenAI response did not include content.');
  }

  try {
    return JSON.parse(content);
  } catch (error) {
    throw new Error('Unable to parse OpenAI JSON payload.');
  }
}

export function getPreferredProvider(): AiProvider {
  return OPENAI_ENABLED ? 'live-openai' : 'simulated';
}

export function describeProvider(provider: AiProvider): string {
  return provider === 'live-openai' ? 'OpenAI live model' : 'Simulated deterministic AI';
}

export async function requestPlan(options: PlanGenerationOptions): Promise<AiPlanResult> {
  if (!OPENAI_ENABLED) {
    const plan = simulatePlan(options);
    return {
      plan,
      provider: 'simulated',
      note: 'Simulated plan generated locally.'
    };
  }

  try {
    const focusAreas = options.focusAreas?.length ? options.focusAreas.join(', ') : 'core functionality';
    const json = await callOpenAi([
      {
        role: 'system',
        content:
          'You are Traycer, a senior staff engineer planning assistant. Respond in JSON with a `plan` array of steps containing `title`, `detail`, optional `status`, and optional `blockedBy` references. Status should be one of todo, in-progress, or done.'
      },
      {
        role: 'user',
        content: `Task prompt: ${options.prompt}\nFocus areas: ${focusAreas}\nTone: ${options.tone ?? 'succinct'}\nEmphasise automated tests: ${options.emphasizeTests ? 'yes' : 'no'}`
      }
    ]);

    const plan = ensurePlanSteps(json?.plan);
    if (plan.length === 0) {
      throw new Error('OpenAI response did not contain valid plan steps.');
    }

    return {
      plan,
      provider: 'live-openai',
      note: json?.note || 'Plan generated via OpenAI.'
    };
  } catch (error) {
    console.error('OpenAI planning failed, falling back to simulation.', error);
    const plan = simulatePlan(options);
    return {
      plan,
      provider: 'simulated',
      note: 'OpenAI plan fallback: using simulated planner.',
      warning: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

export async function requestImplementationSketch(
  plan: PlanStep[],
  options?: ImplementationSeedOptions
): Promise<AiImplementationResult> {
  if (!OPENAI_ENABLED) {
    const changes = simulateImplementation(plan, options);
    return {
      changes,
      provider: 'simulated',
      note: 'Simulated implementation sketch generated locally.'
    };
  }

  try {
    const planSummary = plan
      .map((step, index) => `${index + 1}. ${step.title} (${step.status})`)
      .join('\n');
    const json = await callOpenAi([
      {
        role: 'system',
        content:
          'You are Traycer, an implementation planning assistant. Respond in JSON with a `changes` array. Each change must include `filePath`, `summary`, `rationale`, `before`, `after`, optional `status`, and optional `relatedPlanStepIds` referencing the supplied plan identifiers.'
      },
      {
        role: 'user',
        content: `Plan summary with identifiers:\n${planSummary}\nFocus seed options: ${JSON.stringify(options ?? {})}`
      }
    ]);

    const changes = ensureCodeChanges(json?.changes).map((change) => ({
      ...change,
      relatedPlanStepIds: change.relatedPlanStepIds.filter((id) => plan.some((step) => step.id === id))
    }));

    if (changes.length === 0) {
      throw new Error('OpenAI response did not include any implementation changes.');
    }

    return {
      changes,
      provider: 'live-openai',
      note: json?.note || `Generated ${changes.length} change${changes.length === 1 ? '' : 's'} via OpenAI.`
    };
  } catch (error) {
    console.error('OpenAI implementation fallback triggered.', error);
    const changes = simulateImplementation(plan, options);
    return {
      changes,
      provider: 'simulated',
      note: 'OpenAI implementation fallback: using simulated sketch.',
      warning: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

export async function requestReviewComments(
  changes: CodeChange[],
  options?: ReviewRunOptions
): Promise<AiReviewResult> {
  if (!OPENAI_ENABLED) {
    const reviews = simulateReview(changes, options);
    return {
      reviews,
      provider: 'simulated',
      note: 'Simulated review feedback generated locally.'
    };
  }

  try {
    const changeDigest = changes
      .map((change) => `- ${change.filePath} (${change.status}): ${change.summary}`)
      .join('\n');
    const json = await callOpenAi([
      {
        role: 'system',
        content:
          'You are Traycer, an AI code reviewer. Respond in JSON with a `reviews` array. Each review should include `filePath`, `message`, optional `suggestion`, `severity` (info, warning, or error), optional `line`, and `resolved` boolean.'
      },
      {
        role: 'user',
        content: `Evaluate the following changes:\n${changeDigest || 'No changes'}\nReview strictness: ${options?.strictness ?? 'balanced'}`
      }
    ]);

    const reviews = ensureReviewComments(json?.reviews);
    if (reviews.length === 0) {
      throw new Error('OpenAI response did not include review feedback.');
    }

    return {
      reviews,
      provider: 'live-openai',
      note: json?.note || `Received ${reviews.length} review item${reviews.length === 1 ? '' : 's'} from OpenAI.`
    };
  } catch (error) {
    console.error('OpenAI review fallback triggered.', error);
    const reviews = simulateReview(changes, options);
    return {
      reviews,
      provider: 'simulated',
      note: 'OpenAI review fallback: using simulated reviewer.',
      warning: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
